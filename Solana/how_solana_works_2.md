## 账户模型

> “在 SVM 中分离代码和状态是最好的设计决策。那些虔诚地将这个概念灌输到我脑海中的嵌入式系统开发者是有福的。” — Anatoly Yakovenko，Solana 联合创始人

在 Solana 验证者中，全局状态保存在称为 AccountsDB 的账户数据库中。该数据库负责存储所有账户，无论是在内存中还是在磁盘上。账户索引中的主要数据结构是哈希图，使得 AccountsDB 本质上是一个庞大的[键值存储](https://en.wikipedia.org/wiki/Key%E2%80%93value_database) 。在这里，键是账户地址，值是账户数据。

随着时间的推移，Solana 账户的数量激增至数亿。这一大数量部分是因为，正如 Solana 开发者喜欢说的那样，“Solana 上的一切都是一个账户！”

![](https://img.learnblockchain.cn/attachments/migrate/1723540143402)

### Solana 账户

账户是一个持久保存数据的容器，类似于计算机上的文件。它们有多种形式：

*   用户账户：这些账户有一个私钥，通常由钱包软件为用户生成。
*   数据账户：这些账户存储状态信息，例如用户持有的特定代币数量。
*   程序账户：这些是包含可执行字节码的大型账户，有点类似于 Windows 上的 .exe 文件或 Mac 上的 .app 文件。
*   原生程序账户：这些是执行网络各种核心功能的特殊预部署程序账户。 [示例](https://github.com/solana-labs/solana/tree/master/programs)包括投票程序和 BPF 加载器。

所有账户都有以下字段：

![](https://img.learnblockchain.cn/attachments/migrate/1723540143872)

### 程序

Solana 程序账户仅包含可执行逻辑。这意味着当程序运行时，它会改变其他账户的状态，但自身保持不变。这种代码和状态的分离使 Solana 与其他区块链不同，并支持其许多优化。开发者主要使用 Rust 编写这些程序，这是一种以安全性和性能为重点的通用编程语言。此外，还有多个 TypeScript 和 Python 的 SDK 可用，以便创建应用程序前端并实现与网络的程序化交互。

许多常见功能由原生程序开箱即用地提供。例如，Solana 不需要开发者部署代码来创建代币。相反，指令被发送到一个预部署的原生程序，该程序将设置一个账户来存储代币的元数据，从而有效地创建一个新代币。

### 租金

租金是一种旨在激励用户关闭账户并减少状态爆炸（bloat，膨胀）的机制。要创建一个新账户，账户必须持有一个称为“免租金”金额的最低 SOL 余额。这可以被视为在验证者内存中保持账户存活的存储成本。如果账户数据的大小增加，最低余额租金要求会成比例增加。当账户不再需要时，可以关闭账户，租金将返还给账户所有者。

例如，如果用户持有美元计价的稳定币，这种状态存储在一个代币账户中。目前，代币账户的免租金金额为 0.002 SOL。如果用户将其全部稳定币余额转移给朋友，则可以关闭代币账户，用户将收回其 0.002 SOL。程序通常会自动为用户处理账户关闭。几种应用程序可帮助用户清理旧的、未使用的账户并收回存储在其中的小额 SOL。

### 所有权

虽然读取账户数据是普遍允许的，但 Solana 的所有权模型通过严格限制谁可以修改（写入）账户数据来增强安全性。这一概念对于在 Solana 区块链上执行规则和权限至关重要。每个账户都有一个程序“所有者”。账户的所有者负责管理它，确保只有授权的程序可以更改账户的数据。此规则的一个显著例外是 lamports（SOL 的最小单位）的转移——增加账户的 lamports 余额是普遍允许的，无论所有权如何。

### 状态存储

Solana 程序作为只读可执行文件，必须使用“程序派生地址”（PDAs）存储状态。PDAs 是与程序关联并由程序拥有的特殊类型账户，而不是特定用户。虽然普通的 Solana 用户地址是从 Ed25519 密钥对的公钥派生的，但 PDAs 没有私钥。相反，它们的公钥是从一组参数（通常是关键字或其他账户地址）以及拥有程序的程序 ID（地址）组合派生的。

PDA 地址存在于“曲线外”，这意味着它们不像普通地址那样在 Ed25519 曲线上。只有拥有 PDA 的程序可以程序化地为其生成签名，确保只有它可以修改 PDA 的状态。

![](https://img.learnblockchain.cn/attachments/migrate/1723540143878)

上图：Solana 代币账户是程序派生地址（PDAs）的具体示例。它们用于持有代币并存在于“曲线外”。关联代币账户（ATA）程序确保每个钱包只能有一个关联的代币账户用于每种代币类型，提供了一种标准化的代币账户管理方式。

## Turbine

> “Solana 最有趣的部分不是并行化、SVM 或 Toly 的推文。而是你可能没听说过的东西：Turbine。” — Mert Mumtaz，Helius

在银行阶段，交易被组织成条目并发送到历史证明流进行时间戳记。区块的银行被更新，条目现在准备进入下一个阶段——Turbine。

Turbine 是领导者将其区块传播到网络其余部分的过程。受 [BitTorrent](https://www.bittorrent.com/) 启发，它设计得快速高效，减少通信开销并最小化领导者需要发送的数据量。

![](https://img.learnblockchain.cn/attachments/migrate/1723540143876)

Turbine 通过一个称为“分片”的过程将交易数据分解为“碎片”来实现这一目标。碎片是小的数据包，最多 1280 字节，类似于视频流中的单个帧。当重新组装时，这些碎片允许验证者重播整个区块。这些碎片通过互联网使用 UDP 在验证者之间传输，并利用纠删码来处理数据包丢失或恶意丢包。 [纠删码](https://www.cs.cmu.edu/~guyb/realworld/reedsolomon/reed_solomon_codes.html#) ，一种基于[多项式](https://en.wikipedia.org/wiki/Polynomial)的错误检测和纠正方案，确保数据完整性。即使一些碎片丢失，区块仍然可以重建。

碎片被分组为称为前向纠错（FEC）批次的批次。默认情况下，这些批次由 64 个碎片（32 个数据碎片 +32 个恢复碎片）组成。数据恢复在每个 FEC 批次内进行，这意味着一个批次中最多一半的数据包可以丢失或损坏，所有数据仍然可以恢复。每 64 个碎片的批次都会进行默克尔树处理，根由领导者签名，并与前一个批次链接。这个过程确保了碎片可以从网络中拥有它们的任何节点安全地获取，因为默克尔树根的链条提供了一个可验证的真实性和完整性路径。

领导者最初向一个根节点广播，根节点将碎片传播给所有其他验证节点。每个碎片的根节点都会变化。验证者被组织成层，形成“Turbine 树”。拥有较大权益的验证者通常位于树的顶部，而那些拥有较少权益的验证者则位于底部。

![](https://img.learnblockchain.cn/attachments/migrate/1723540143880)

树通常跨越两到三跳，具体取决于活跃验证者的数量。为了视觉简洁，上图显示了一个 3 的扇出（fanout），但 Solana 的实际扇出值目前设置为 200。出于安全原因，每个新批次的碎片树的顺序都会旋转。

这种系统的主要目标是减轻领导者和根节点的出站数据出口压力。通过利用传输和重传系统，负载在领导者和重传者之间分配，减少了任何单个节点的压力。

### 共识

> “一些聪明的人告诉我，Solana 有一个真诚的聪明的开发者社区……我希望这个社区能有公平的机会茁壮成长” — Vitalik Buterin，以太坊联合创始人

一旦验证者通过 Turbine 从领导者那里接收到一个新区块，它必须验证每个条目中的所有交易。这涉及重播整个区块，平行验证 PoH 哈希，按照 PoH 规定的顺序重新创建交易，并更新其本地银行。

![](https://img.learnblockchain.cn/attachments/migrate/1723540144035)

这个过程由交易验证单元（TVU）处理，类似于领导者的交易处理单元（TPU），作为处理碎片和区块验证的核心逻辑。与 TPU 一样，TVU 流程分为几个阶段，首先是碎片获取阶段，在该阶段通过 Turbine 接收碎片。在随后的碎片验证领导者签名阶段，碎片经过多次完整性检查，最显著的是验证领导者的签名，以确保 xxx 收到的碎片来自领导者。

在重传阶段，验证者根据其在 Turbine 树中的位置，将碎片转发给适当的下游验证者。在重播阶段，验证者按正确顺序精确地重新创建每个交易，同时更新其本地版本的银行。

重播阶段类似于 TPU 中的银行阶段；这是最重要的阶段，可以更直接地描述为区块验证阶段。重播是一个单线程的过程循环，协调许多关键操作，包括投票、重置 PoH 时钟和切换银行。

![](https://img.learnblockchain.cn/attachments/migrate/1723540144387)

上图：重播阶段负责将验证者切换到领导者模式并开始区块生产。原始视觉：Justin Starry，Anza

### 共识

为了实现共识，Solana 使用了 Tower BFT（TBFT），这是著名的[实用拜占庭容错](https://en.wikipedia.org/wiki/Byzantine_fault) （PBFT）算法的自定义实现，大多数区块链使用 PBFT 算法来就链的状态达成一致。像所有区块链一样，Solana 假设网络中存在恶意节点，因此系统不仅必须承受节点故障，还必须承受一定程度的攻击。

Tower BFT 通过利用历史证明提供的同步时钟与其他链区分开来。虽然传统的 PBFT 需要多轮通信来就交易顺序达成一致，但 Solana 节点利用预先建立的事件顺序，显著减少了消息传递的开销。

### 投票

为了参与共识并获得奖励，验证者提交他们认为有效（即没有双花或错误签名等问题）并被视为规范的区块的投票。验证者为这些投票支付交易费，这些投票由领导者处理并与普通用户交易一起包含在区块中。这就是为什么 Solana 交易通常分为**投票和非投票交易**。当验证者提交正确且成功的投票时，它们会获得一个信用。这一机制激励验证者投票给他们认为最有可能被包含的分叉，即“最重”的分叉。

### 分叉

Solana 之所以如此之快，部分原因在于网络在生成下一个区块之前，不会等待所有验证者就新生成的区块达成一致。因此，两个不同的区块链接到同一个父区块，从而产生分叉的情况并不少见。

Solana 验证者必须对这些分叉进行投票，并使用共识算法决定采用哪个分叉。当存在相互竞争的分叉时，网络最终只会确定一个分叉，而被丢弃的分叉中的区块则会被废弃。

每个插槽都有一个预先确定的领导者，只有该领导者的区块才会被接受；一个插槽不可能有两个提议的区块。因此，潜在分叉的数量被限制在一个“there/not-there”的分叉跳转列表中，这些分叉可能出现在领导者节点轮换插槽边界上。一旦验证者选择了一个分支，它就会被提交到这个分支，直到锁定时间到期，这意味着它必须在最短的时间内坚持自己的选择。

![](https://img.learnblockchain.cn/attachments/migrate/1723540144391)

Solana 的“跳过率”——没有产生区块的槽的百分比——在 2% 到 10% 之间波动，分叉是这些跳过插槽的主要原因。其他可能的跳过槽的原因包括：新 epoch 的开始、领导者节点离线或生成无效区块。

**记住**

_交易在 Solana 上的状态因其在共识过程中的当前阶段而不同：_

_\- 已处理：交易已包含在区块中。_

_\- 已确认：交易的区块已获得 2/3 的超级多数投票。_

_\- 已最终确定：交易的区块上已构建了超过 31 个区块。_

_迄今为止，Solana 的历史上从未出现过（乐观地）确认的区块未能最终确定的情况。_

对于每个区块，Solana 使用一个银行来访问该区块的状态。当一个银行被最终确定时，该银行及其祖先的账户更新会被刷新到磁盘。此外，任何来自早期银行且不是最终确定银行祖先的账户更新都会被修剪。这个过程允许 Solana 高效地维护多个潜在状态。

### Gossip + Archive

> “区块链需要巧妙地结合密码学、分布式系统、操作系统和编程语言。Solana 的超能力在于愿意逃避每个学科中最有趣的问题。” — Greg Fitzgerald，Solana 联合创始人

### Gossip

Gossip 网络可以被视为 Solana 网络的[控制平面](https://en.wikipedia.org/wiki/Control_plane) 。与处理交易流的数据平面不同，控制平面传播关于区块链状态的重要元数据，例如联系信息、分布式账本高度和投票信息。没有 Gossip，验证器和 RPC 就不知道哪些地址和端口开放供各种服务进行通信。新节点也依赖 Gossip 加入网络。

Solana 的 Gossip 协议使用非正式的点对点通信，采用树状广播方式，其灵感来源于改进的 PlumTree 算法。这种方法高效地传播信息，而不依赖任何中心来源。

Gossip 在某种程度上作为一个独立的系统运行，与大多数其他验证者组件无关。验证者和 RPC 每 0.1 秒通过 UDP 以 Gossip 方式共享签名数据对象，确保信息在网络中的可用性。所有 Gossip 消息必须小于或等于 1280 字节的最大传输单元（MTU），在代码库中称为“数据包结构”。

Gossip 记录是节点之间共享的实际数据对象。大约有 10 种不同类型的记录，每种记录都有不同的用途。Gossip 记录有签名、版本和时间戳，以确保完整性和时效性。

Gossip 消息有四种类型：

* Push：最常见的消息，与一部分“push peers”共享信息。

* Pull & Pull Response:：定期检查是否有遗漏的消息，拉取响应会发送节点没有的信息。

* Prune：允许节点选择性地减少它们维护的连接数量。

* Ping 和 Pong：节点的健康检查——如果发送了 ping，则期望返回 pong，表示节点仍然活跃。

Gossip 数据存储在集群复制数据存储（CrdsTable）中。这个数据结构可以变得非常大，需要定期修剪。

### Archive

Solana 与其他区块链的不同之处在于，它不需要整个历史记录来确定账户的当前状态。Solana 的帐户模型确保任何给定插槽的状态是已知的，允许验证者在不处理所有历史区块的情况下存储每个账户的当前状态。RPC 和验证者在设计上不保留整个历史账本。相反，它们通常只存储 1 或 2 个 epoch（2-4 天）的交易数据，这足以验证链的最新插槽。

档案目前由“仓库节点”管理，由专业的 RPC 服务提供商、Solana 基金会和其他有兴趣确保交易历史可用的生态系统参与者运营。
仓库节点通常维护以下一个或两个节点：

1. 分布式账本档案：上传原始的分布式账本和 AccountsDB 快照，适合从头开始重播。

2. Google Bigtable 实例：存储从创世区块开始的区块数据，格式化后可满足 RPC 请求。

### Economics + Jito

> “人们正在意识到 Solana 是今天唯一可用的支持主流消费应用的链。” — Ted Livingston，创始人 Code

Solana 通过在每个 epoch 发行新的 SOL 代币来分配质押奖励，从而实现通货膨胀。这一过程导致非质押者的网络份额相对于质押者减少，从而导致财富从非质押者转移到质押者。通货膨胀机制于 2021 年初启动，初始年通胀率为 8%，每年减少 15%，直到长期稳定在 1.5%。

![](https://img.learnblockchain.cn/attachments/migrate/1723540144395)

任何 SOL 代币持有者都可以获得奖励，并通过将代币质押给一个或多个验证者来帮助保护网络。将代币分配给验证者称为委托。将代币委托给验证者表示对验证者的信任。然而，这并不赋予验证者对代币的所有权或控制权。所有质押、取消质押和委托操作都在下一个新 epoch 开始时执行。

**投票奖励**

当验证者提交投票时，如果投票准确且成功，他们会获得一个信用点。投票交易费用为 0.000005 SOL，免收优先权费用。每个验证者每天的投票费用约为 1 SOL，这也是验证者的主要运营成本。在整个 epoch 中，验证者通过投票积累信用点，在 epoch 结束时可兑换通胀份额。

表现最出色的验证者成功地对大约 90% 的插槽进行了投票。需要注意的是，没有区块的插槽百分比 (跳过的插槽率) 范围从 2% 到 10% 以上，这些插槽不能投票。验证者平均在大约 80% 的插槽上成功投票，在 432,000 个插槽中获得 345,600 个信用点。

通货膨胀总额首先是根据该时期获得的信用点来划分的。验证者在总信用点数中的份额（其信用点数除以所有验证者的信用点数总和）决定了其奖励比例。这是进一步加权的赌注。

因此，如果验证者的信用点数处于平均水平，那么他所获得的奖励大约为总质押的 1%。如果他们的信用点数高于或低于平均值，他们的奖励也会相应波动。

投票表现的差异是验证者向质押者提供的回报（以年收益率衡量）不同的原因之一。另一个因素是验证者收取的佣金率，这是针对验证者的通胀奖励总额的一个百分比。此外，验证者离线或与区块链不同步（称为延迟）也会对回报产生重大影响。‍

**区块奖励**

被指定为特定区块领导者的验证者将获得额外的区块奖励。这些奖励包括区块内所有交易的 50% 基础费用和 50% 优先费用，其余费用将被销毁。只有生成区块的验证者才能获得这些奖励。与每个 epoch 分发的质押奖励不同，区块奖励在区块生成时立即记入验证者的身份账户。

投票表现的差异是验证者提供给股东的回报 (以 APY 衡量) 不同的原因之一。另一个因素是验证者收取的佣金率，这是指向其验证者的总通货膨胀奖励的百分比。此外，验证器离线或与区块链不同步 (称为拖欠) 会严重影响回报。

投票表现的差异是验证人向认购人提供的回报（以年利率衡量）不同的原因之一。另一个因素是验证者收取的佣金率，这是针对验证者的通胀奖励总额的一个百分比。此外，验证者离线或与区块链不同步（称为延迟）也会对回报产生重大影响。

### 流动质押

流动质押已成为本地质押的热门替代方案。参与者在质押他们的 SOL 时会收到一种代币，称为流动质押代币（LST）或流动质押衍生品（LSD），作为对其 SOL 质的回报，通常是在一个定投池中，将代币委托给多个验证者。新收到的 LST 代币代表用户所质押 SOL 的份额。这些代币可以交易、跨应用使用或转移给他人，同时仍然赚取质押奖励。该系统的主要优势是显著提高了资本效率。

`Price of LST = (total staked SOL in pool * price of SOL) / total LST minted`

在传统的本地质押中，随着时间的推移，质押者将直接累积更多的 SOL。而在流动质押中，奖励会重新投资回池中，从而增加 LST 的公允价值。只要有机制可以将 LST 兑换为底层质押的 SOL，套利交易者将确保代币价格保持合理。

### Jito
‍
截至撰写本文时，超过 80% 的 Solana 质押使用了 Jito 客户端验证软件（ [来源](https://jito.retool.com/embedded/public/3557dd68-f772-4f4f-8a7b-f479941dba02) ）。这个客户端是原始 Agave 客户端的一个分支，通过协议外的区块空间拍卖为验证者提供额外的经济激励。这种额外的激励是 Jito 客户端在验证者中广泛采用的主要因素。

当领导者使用 Jito 验证客户端时，他们的交易最初会被定向到 Jito-Relayer。这款开源软件充当交易代理路由器。其他网络节点不知道 Jito-Relayer 的存在，因为它们只是将交易发送到领导者节点在 gossip 网络上公布的地址和端口配置，认为这是领导者节点的 ingress_socket。

![](https://cdn.prod.website-files.com/641ba798c17bb180d832b666/66b41fe65de8a0d019876ca2_66b41fd8bd58bc7bf7d972c8_Solana%2520Report%2520Visuals%2520for%2520Helius%2520Blog.pptx%2520(15).png)

中继器将所有交易保留 200 毫秒，然后再转发给领导者节点。这种“减速带”机制会延迟传入的交易消息，为进行拍卖提供了一个简短的窗口。在 200 毫秒后，中继器乐观地释放交易，而不管拍卖结果如何。

区块空间拍卖通过 Jito 区块引擎在链下进行，允许搜索者和应用程序提交一组原子执行的交易，称为捆绑（bundles）。这些捆绑通常包含时间敏感的交易，如套利或清算。Jito 对所有小费收取 5% 的费用，最低小费为 10,000 lamports。小费完全在协议外操作，与协议内的优先费和基础费用分开。之前，Jito 运营了一个规范的协议外内存池服务，现已废弃。
